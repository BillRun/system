<?php

/**
 * @package         Billing
 * @copyright       Copyright (C) 2012-2016 BillRun Technologies Ltd. All rights reserved.
 * @license         GNU Affero General Public License Version 3; see LICENSE.txt
 */

/**
 * Billing realtime controller class
 * Used for events in real-time
 * 
 * @package  Controller
 * @since    5.3
 */
class RealtimeController extends ApiController {

	use Billrun_Traits_Api_UserPermissions;

	protected $config = null;
	protected $event = null;
	protected $file_type = null;

	public function indexAction() {
		$this->execute();
	}

	/**
	 * method to execute real-time event
	 */
	public function execute() {
		$this->allowed();
		Billrun_Factory::log("Execute realtime event", Zend_Log::INFO);
		$this->setDataFromRequest();
		$this->setEventData();
		$data = $this->process();
		return $this->respond($data);
	}

	/**
	 * Gets the data sent to the controller
	 */
	protected function setDataFromRequest() {
		$request = $this->getRequest()->getRequest();
		$this->config = $this->getConfig();
		if (!$this->config) {
			Billrun_Factory::log('File type cannot be loaded', Zend_Log::ALERT);
			throw new Billrun_Exceptions_Api(10000, 'Cannot load file type');
		}
		$decoder = Billrun_Decoder_Manager::getDecoder(array(
				'decoder' => $this->config['parser']['type']
		));
		if (!$decoder) {
			Billrun_Factory::log('Cannot get decoder', Zend_Log::ALERT);
			return false;
		}

		if (!empty($request['request'])) {
			$requestBody = $request['request'];
		} else {
			$requestBody = file_get_contents("PHP://input");
		}

		$this->event['uf'] = $decoder->decode($requestBody);
	}
	
	/**
	 * get input processor configuration
	 *
	 * @return array
	 */
	protected function getConfig() {
		$request = $this->getRequest()->getRequest();
		return Billrun_Factory::config()->getFileTypeSettings($request['file_type'], true);
	}

	/**
	 * Sets the data of $this->event
	 */
	protected function setEventData() {
		$this->event['source'] = 'realtime';
		$this->event['type'] = $this->getEventType();
		$this->event['request_type'] = $this->getRequestType();
		$recordType = $this->getDataRecordType($this->event);
		if ($recordType != 'postpay_charge_request') {
			$this->event['session_id'] = $this->getSessionId();
		}
		$this->event['record_type'] = $recordType;
		$this->event['billrun_pretend'] = $this->isPretend($this->event);

		Billrun_Factory::dispatcher()->trigger('realtimeAfterSetEventData', array(&$this->event));
	}

	protected function getDataRecordType($data) {
		$requestCode = $data['request_type'];
		$requestTypes = Billrun_Factory::config()->getConfigValue('realtimeevent.requestType', array());
		foreach ($requestTypes as $requestTypeDesc => $requestTypeCode) {
			if ($requestCode == $requestTypeCode) {
				return strtolower($requestTypeDesc);
			}
		}

		Billrun_Factory::log("No record type found. Params: " . print_R($data, 1), Zend_Log::ERR);
		return false;
	}

	/**
	 * Gets the event type for rates calculator
	 * 
	 * @return string event type
	 * @todo Get values from config
	 */
	protected function getEventType() {
		return $this->config['file_type'];
	}

	/**
	 * Gets the request type from the request
	 * 
	 * @return string request type
	 */
	protected function getRequestType() {
		if (Billrun_Utils_Realtime::getRealtimeConfigValue($this->config, 'postpay_charge', 'general', false)) {
			$this->event['skip_calc'] = array('unify');
			return Billrun_Factory::config()->getConfigValue('realtimeevent.requestType.POSTPAY_CHARGE_REQUEST', "4");
		}
		
		$requestTypeField = Billrun_Utils_Realtime::getRealtimeConfigValue($this->config, 'request_type_field');
		if (!$requestTypeField) {
			return (isset($this->event['uf']['request_type']) ? $this->event['uf']['request_type'] : null);
		}
		return $this->event['uf'][$requestTypeField];
	}

	/**
	 * Gets the request session id from the request
	 * 
	 * @return string session id
	 */
	protected function getSessionId() {
		$sessionIdFields = Billrun_Utils_Realtime::getRealtimeConfigValue($this->config, 'session_id_fields');
		if (empty($sessionIdFields)) {
			return (isset($this->event['uf']['session_id']) ? $this->event['uf']['session_id'] : Billrun_Util::generateRandomNum());
		}

		$sessionIdArr = array_intersect_key($this->event['uf'], array_flip($sessionIdFields));
		return Billrun_Util::generateArrayStamp($sessionIdArr);
	}

	/**
	 * Runs Billrun process
	 * 
	 * @return type Data generated by process
	 */
	protected function process() {
		$options = $this->config;
		$parserFields = $options['parser']['structure'];
		foreach ($parserFields as $field) {
			if (isset($field['checked']) && $field['checked'] === false) {
				if (strpos($field['name'], '.') !== false) {
					$splittedArray = explode('.', $field['name']);
					$lastValue = array_pop($splittedArray);
					Billrun_Util::unsetIn($this->event['uf'], $splittedArray, $lastValue);
				} else {
					unset($this->event['uf'][$field['name']]);
				}
			}
		}
		$options['parser'] = 'none';
		$processor = Billrun_Processor::getInstance($options);
		if ($processor) {
			$multiLines = !Billrun_Util::isAssoc($this->event);
			$rows = $multiLines ? $this->event : [$this->event];
			foreach ($rows as $row) {
				$processor->addDataRow($row);
			}
			$processor->process($this->config);
			$data = $processor->getData()['data'];
			$allLines = $processor->getAllLines();
			return $multiLines ? $allLines : current($allLines);
		}
	}

	/**
	 * Send respond
	 * 
	 * @param type $data
	 * @return boolean
	 */
	protected function respond($data) {
		$encoder = Billrun_Encoder_Manager::getEncoder(array(
				'encoder' => $this->config['response']['encode']
		));
		if (!$encoder) {
			Billrun_Factory::log('Cannot get encoder', Zend_Log::ALERT);
			return false;
		}

		$responderParams = array(
			'data' => $data,
			'config' => $this->config,
		);
		$responder = Billrun_ActionManagers_Realtime_Responder_Manager::getResponder($responderParams);
		if (!$responder) {
			Billrun_Factory::log('Cannot get responder', Zend_Log::ALERT);
			return false;
		}

		Billrun_Factory::dispatcher()->trigger('realtimeBeforeGetResponse', array(&$data));
		$response = $responder->getResponse();
		Billrun_Factory::dispatcher()->trigger('realtimeAfterGetResponse', array($data, &$response));
		$params = array('root' => 'response');
		$response = $encoder->encode($response, $params);
		$this->setOutput(array($response, 1));

		Billrun_Factory::log("Realtime req: " . print_R($this->event, 1), Billrun_Log::DEBUG);
		Billrun_Factory::log("Realtime res: " . print_R($response, 1), Billrun_Log::DEBUG);
		$this->updateLineResponse($data, $response);
		return $response;
	}
	
	/**
	 * method to return the collection the initial line exists
	 * in prepaid it would be archive collection, while postpaid it will be lines collection
	 * 
	 * @return Mongodloid_Collection
	 */
	protected function getBaseCollection() {
		if ($this->config['realtime']['postpay_charge']) {
			return Billrun_Factory::db()->linesCollection();
		}
		return Billrun_Factory::db()->archiveCollection();
	}
	
	/**
	 * method to store the api response
	 * 
	 * @param array $data the line data
	 * @param array $response realtime api response
	 */
	protected function updateLineResponse($data, $response) {
		$coll = $this->getBaseCollection();
		$query = array(
			'stamp' => $data['stamp'],
		);
		$update = array(
			'$set' => array(
				'response' => (array) $response,
			)
		);
		$coll->update($query, $update);
	}

	/**
	 * Checks if the row should really decrease balance from the subscriber's balance, or just pretend
	 * 
	 * @return boolean
	 */
	protected function isPretend($event) {
		$pretendField = Billrun_Utils_Realtime::getRealtimeConfigValue($this->config, 'pretend_field', 'general', 'pretend');
		return (isset($event['uf'][$pretendField]) && $event['uf'][$pretendField]);
	}

	protected function getPermissionLevel() {
		return Billrun_Traits_Api_IUserPermissions::PERMISSION_ADMIN;
	}
	
	/**
	 * allows setting an HTTP status code for the response
	 *
	 * @param  int $httpStatusCode
	 */
	protected function setHttpStatusCode($httpStatusCode) {
		$this->getResponse()->setHeader($this->getRequest()->getServer('SERVER_PROTOCOL'), $httpStatusCode);
	}

}
