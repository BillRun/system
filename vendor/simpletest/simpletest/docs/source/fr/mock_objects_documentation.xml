<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id$ -->
<page title="Documentation sur les objets fantaisie" here="Les objets fantaisie">
    <synchronisation lang="en" version="2008" date="08/06/2011" maintainer="pp11" />
    <long_title>Documentation SimpleTest : les objets fantaise</long_title>
    <content>
        <section name="what" title="Que sont les objets fantaisie ?">
            <p>
                Les objets fantaisie - ou &quot;mock objects&quot; en anglais -
                ont deux rôles pendant un scénario de test : acteur et critique.
            </p>
            <p>
                Le comportement d'acteur est celui de simuler
                des objets difficiles à initialiser ou trop consommateurs
                en temps pendant un test.
                Le cas classique est celui de la connexion à une base de données.
                Mettre sur pied une base de données de test au lancement
                de chaque test ralentirait considérablement les tests
                et en plus exigerait l'installation d'un moteur
                de base de données ainsi que des données sur la machine de test.
                Si nous pouvons simuler la connexion
                et renvoyer des données à notre guise
                alors non seulement nous gagnons en pragmatisme
                sur les tests mais en sus nous pouvons nourrir
                notre base avec des données falsifiées
                et voir comment il répond. Nous pouvons
                simuler une base de données en suspens ou
                d'autres cas extrêmes sans avoir à créer
                une véritable panne de base de données.
                En d'autres termes nous pouvons gagner
                en contrôle sur l'environnement de test.
            </p>
            <p>
                Si les objets fantaisie ne se comportaient que comme
                des acteurs alors on les connaîtrait sous le nom de
                <a local="server_stubs_documentation">bouchons serveur</a>.
                Il s'agissait originairement d'un patron de conception
                identifié par Robert Binder (<a href="">Testing
                object-oriented systems</a>: models, patterns, and tools,
                Addison-Wesley) en 1999.
            </p>
            <p>
                Un bouchon serveur est une simulation d'un objet ou d'un composant.
                Il doit remplacer exactement un composant dans un système
                en vue d'effectuer des tests ou un prototypage,
                tout en restant ultra-léger.
                Il permet aux tests de s'exécuter plus rapidement, ou 
                si la classe simulée n'a pas encore été écrite,
                de se lancer tout court.
            </p>
            <p>
                Cependant non seulement les objets fantaisie jouent
                un rôle (en fournissant à la demande les valeurs requises)
                mais en plus ils sont aussi sensibles aux messages qui
                leur sont envoyés (par le biais d'attentes).
                En posant les paramètres attendus d'une méthode
                ils agissent comme des gardiens :
                un appel sur eux doit être réalisé correctement.
                Si les attentes ne sont pas atteintes ils nous épargnent
                l'effort de l'écriture d'une assertion de test avec
                échec en réalisant cette tâche à notre place.
            </p>
            <p>
                Dans le cas d'une connexion à une base de données
                imaginaire ils peuvent tester si la requête, disons SQL,
                a bien été formé par l'objet qui utilise cette connexion.
                Mettez-les sur pied avec des attentes assez précises
                et vous verrez que vous n'aurez presque plus d'assertion à écrire manuellement.
            </p>
        </section>
        <section name="creation" title="Créer des objets fantaisie">
            <p>
                Tout ce dont nous avons besoin est une classe existante ou une interface,
                par exemple une connexion à la base de données qui ressemblerait à...
<php><![CDATA[
<strong>class DatabaseConnection {
    function DatabaseConnection() { }
    function query($sql) { }
    function selectQuery($sql) { }
}</strong>
]]></php>
                Pour en créer sa version fantaisie nous devons juste
				lancer le générateur...
<php><![CDATA[
require_once('simpletest/autorun.php');
require_once('database_connection.php');

<strong>Mock::generate('DatabaseConnection');</strong>
]]></php>
                Ce code génère une classe clone appelée <code>MockDatabaseConnection</code>.
                Cette nouvelle classe lui ressemble en tout point,
                sauf qu'elle ne fait rien du tout.
            </p>
            <p>
            	Cette nouvelle classe est génératlement
            	une sous-classe de <code>DatabaseConnection</code>.
            	Malheureusement, il n'y as aucun moyen de créer une version fantaisie
            	d'une classe avec une méthode <code>final</code> sans avoir
            	une version fonctionnelle de cette méthode.
            	Ce n'est pas pas très satisfaisant.
            	Si la cible est une interface ou si les méthodes <code>final</code>
            	existent dans la classe cible, alors une toute nouvelle classe
            	est créée, elle implémente juste les même interfaces.
            	Si vous essayer de faire passer cette classe à travers un indice de type
            	qui spécifie le véritable nom de l'ancienne classe, alors il échouera.
            	Du code qui forcerait un indice de type tout en utilisant
            	des méthodes <code>final</code> ne pourrait probablement pas être
            	testé efficacement avec des objets fantaisie.
            </p>
            <p>
                Si vous voulez voir le code généré, il suffit de faire un <code>print</code>
                de la sortie de <code>Mock::generate()</code>.
                VOici le code généré pour la classe <code>DatabaseConnection</code>
                à la place de son interface...
<php><![CDATA[
class MockDatabaseConnection extends DatabaseConnection {
    public $mock;
    protected $mocked_methods = array('databaseconnection', 'query', 'selectquery');

    function MockDatabaseConnection() {
        $this->mock = new SimpleMock();
        $this->mock->disableExpectationNameChecks();
    }
    ...
    function DatabaseConnection() {
        $args = func_get_args();
        $result = &$this->mock->invoke("DatabaseConnection", $args);
        return $result;
    }
    function query($sql) {
        $args = func_get_args();
        $result = &$this->mock->invoke("query", $args);
        return $result;
    }
    function selectQuery($sql) {
        $args = func_get_args();
        $result = &$this->mock->invoke("selectQuery", $args);
        return $result;
    }
}
]]></php>
                Votre sortie dépendra quelque peu de votre version précise de SimpleTest.
            </p>
            <p>
                En plus des méthodes d'origine de la classe, vous en verrez d'autres
                pour faciliter les tests.
                Nous y reviendrons.
            </p>
            <p>
                Nous pouvons désormais créer des instances de
                cette nouvelle classe à l'intérieur même de notre scénario de test...
<php><![CDATA[
require_once('simpletest/autorun.php');
require_once('database_connection.php');

Mock::generate('DatabaseConnection');

class MyTestCase extends UnitTestCase {

    function testSomething() {
        <strong>$connection = new MockDatabaseConnection();</strong>
    }
}
]]></php>
                La version fantaisie contient toutles méthodes de l'originale.
                En outre, tous les indices de type seront préservés.
                Dison que nos méthodes de requête attend un objet <code>Query</code>...
<php><![CDATA[
<strong>class DatabaseConnection {
    function DatabaseConnection() { }
    function query(Query $query) { }
    function selectQuery(Query $query) { }
}</strong>
]]></php>
                Si nous lui passons le mauvais type d'objet
                ou même pire un non-objet...
<php><![CDATA[
class MyTestCase extends UnitTestCase {

    function testSomething() {
        $connection = new MockDatabaseConnection();
        $connection->query('insert into accounts () values ()');
    }
}
]]></php>
                ...alors le code renverra une violation de typage,
                exactement comme on aurait pû s'y attendre
                avec la classe d'origine.
            </p>
            <p>
                Si la version fantaisie implémente bien toutes les méthodes
                de l'originale, elle renvoit aussi systématiquement <code>null</code>.
                Et comme toutes les méthodes qui renvoient toujours <code>null</code>
                ne sont pas très utiles, nous avons besoin de leur faire dire
                autre chose...
            </p>
        </section>
        <section name="bouchon" title="Objets fantaisie en action">
            <p>
                Changer le <code>null</code> renvoyé par la méthode fantaisie
                en autre chose est assez facile...
<php><![CDATA[
<strong>$connection->returns('query', 37)</strong>
]]></php>
                Désormais à chaque appel de <code><![CDATA[$connection->query()]]></code>
                nous obtenons un résultat de 37.
                Il n'y a rien de particulier à cette valeur de 37.
                Cette valeur de retour peut être aussi compliqué que nécessaire.
            </p>
            <p>
                Ici les paramètres ne sont pas significatifs,
                nous aurons systématiquement la même valeur en retour
                une fois initialisés de la sorte.
                Cela pourrait ne pas ressembler à une copie convaincante
                de notre connexion à la base de données, mais pour
                la demi-douzaine de lignes de code de notre méthode de test
                c'est généralement largement assez.
            </p>
            <p>
                Sauf que les choses ne sont pas toujours si simples.
                Les itérateurs sont un problème récurrent, si par exemple
                renvoyer systématiquement la même valeur entraine
                une boucle infinie dans l'objet testé.
                Pour ces cas-là, nous avons besoin d'une séquence de valeurs.
				Supposons que nous avons un itérateur simple qui ressemble à...
<php><![CDATA[
class Iterator {
    function Iterator() { }
    function next() { }
}
]]></php>
                Il s'agit là de l'itérateur le plus basique que nous puissions imaginer.
                Supponsons que cet itérateur ne renvoit que du texte
                jusqu'à ce qu'il atteigne la fin et qu'il renvoie alors un false,
                nous pouvons le simuler avec...
<php><![CDATA[
Mock::generate('Iterator');

class IteratorTest extends UnitTestCase() {

    function testASequence() {<strong>
        $iterator = new MockIterator();
        $iterator->returns('next', false);
        $iterator->returnsAt(0, 'next', 'First string');
        $iterator->returnsAt(1, 'next', 'Second string');</strong>
        ...
    }
}
]]></php>
                Quand <code>next()</code> est appelé par le <code>MockIterator</code>
                il commencera par renvoyer &quot;First string&quot;,
                au deuxième passage &quot;Second string&quot; sera renvoyé
                et sur n'importe quel autre appel <code>false</code> sera renvoyé
                à son tour.
                Les valeurs renvoyées les unes après les autres auront la priorité
                sur la valeur constante.
                Cette dernière est la valeur par défaut en quelque sorte.
            </p>
            <p>
                Une autre situation délicate serait une opération
                <code>get()</code> surchargée.
                Un exemple serait un conteneur d'information avec des pairs clef/valeur.
                Nous partons cette fois d'une classe de configuration telle...
<php><![CDATA[
class Configuration {
    function Configuration() { ... }
    function get($key) { ... }
}
]]></php>
                C'est une situation courante pour utiliser des objets fantaisie,
                étant donné que la véritable configuration sera différente
                d'une machine à l'autre et parfois même d'un test à l'autre.
                Cependant un problème apparaît quand toutes les données passent
                par la méthode <code>get()</code> et que nous souhaitons
                quand même des résultats différents pour des clefs différentes.
                Par chance les objets fantaisie ont un système de filtre...
<php><![CDATA[
<strong>$config = &new MockConfiguration();
$config->returns('get', 'primary', array('db_host'));
$config->returns('get', 'admin', array('db_user'));
$config->returns('get', 'secret', array('db_password'));</strong>
]]></php>
                Le dernier paramètre est une liste d'arguements
                pour vérifier une correspondance.
                Dans ce cas, nous essayons de faire correspondre un argument
                qui se trouve être la clef de recherche.
                Désormais quand l'objet fantaisie voit
                sa méthode <code>get()</code> invoquée...
<php><![CDATA[
$config->get('db_user')
]]></php>
                ...il renverra &quot;admin&quot;.
                Il trouve cette valeur en essayant de faire correspondre
                l'argument reçu à ceux de ses propres listes : dès qu'une
                correspondance complète est trouvé, il s'arrête.
            </p>
            <p>
                Vous pouvez préciser un argument par défaut via...
<php><![CDATA[<strong>
$config->returns('get', false, array('*'));</strong>
]]></php>
                Ce n'est pas la même chose que de définir la valeur renvoyée
                sans aucun arguement...
<php><![CDATA[<strong>
$config->returns('get', false);</strong>
]]></php>
                Dans le premier cas, il acceptera n'importe quel argument,
                mais il en faut au moins un.
                Dans le deuxième cas, n'importe quel nombre d'arguments
                fera l'affaire and il agit comme un attrape-tout après
                toutes les autres vérifications.
                Notez que si - dans le premier cas - nous ajoutons
                d'autres options avec paramètre unique après le joker,
                alors elle seront ignorés puisque le joker fera
                la première correspondance.
                Avec des listes complexes de paramètres, l'ordre devient
                important au risque de voir la correspondance souhaitée
                masqué par un joker apparu plus tôt.
                Déclarez les plus spécifiques d'abord si vous n'êtes pas sûr.
            </p>
            <p>
                Il y a des moments où vous souhaitez qu'une référence
                bien spécifique soit servie par l'objet fantaisie plutôt
                qu'une copie.
                C'est plutôt rare pour dire le moins, mais vous pourriez 
                être en train de simuler un conteneur qui détiendrait
                des primitives, tels des chaînes de caractères.
                Par exemple.
<php><![CDATA[
class Pad {
    function Pad() { }
    function &note($index) { }
}
]]></php>
                Dans ce cas, vous pouvez définir une référence dans la liste
                des valeurs retournées par l'objet fantaisie...
<php><![CDATA[
function testTaskReads() {
    $note = 'Buy books';
    $pad = new MockPad();
    $vector-><strong>returnsByReference(</strong>'note', $note, array(3)<strong>)</strong>;
    $task = new Task($pad);
    ...
}
]]></php>
                Avec cet assemblage vous savez qu'à chaque fois
                que <code><![CDATA[$pad->note(3)]]></code> est appelé
                il renverra toujours la même <code>$note</code>,
                même si celle-ci est modifiée.
            </p>
            <p>
                Ces trois facteurs, timing, paramètres et références,
                peuvent être combinés orthogonalement.
                Par exemple...
<php><![CDATA[
$buy_books = 'Buy books';
$write_code = 'Write code';
$pad = new MockPad();
$vector-><strong>returnsByReferenceAt(0, 'note', $buy_books, array('*', 3));</strong>
$vector-><strong>returnsByReferenceAt(1, 'note', $write_code, array('*', 3));</strong>
]]></php>
                Cela renverra une référence à <code>$buy_books</code> et
                ensuite à <code>$write_code</code>, mais seuleent si deux paramètres
                sont utilisés, le deuxième devant être l'entier 3.
                Cela devrait couvrir la plupart des situations.
            </p>
            <p>
                Un dernier cas délicat reste : celui d'un objet créant
                un autre objet, plus connu sous le patron de conception "fabrique"
                (ou "factory").
                Supponsons qu'à la réussite d'une requête à
                notre base de données imaginaire, un jeu d'enregistrements
                est renvoyé sous la forme d'un itérateur, où chaque appel
                au <code>next()</code> sur notre itérateur donne une ligne
                avant de s'arrêtre avec un false.
                Cela semble à un cauchemar à simuler, alors qu'en fait un objet
                fantaisie peut être créé avec les mécansimes ci-dessus...
<php><![CDATA[
Mock::generate('DatabaseConnection');
Mock::generate('ResultIterator');

class DatabaseTest extends UnitTestCase {

    function testUserFinderReadsResultsFromDatabase() {<strong>
        $result = new MockResultIterator();
        $result->returns('next', false);
        $result->returnsAt(0, 'next', array(1, 'tom'));
        $result->returnsAt(1, 'next', array(3, 'dick'));
        $result->returnsAt(2, 'next', array(6, 'harry'));

        $connection = new MockDatabaseConnection();
        $connection->returns('selectQuery', $result);</strong>

        $finder = new UserFinder(<strong>$connection</strong>);
        $this->assertIdentical(
                $finder->findNames(),
                array('tom', 'dick', 'harry'));
    }
}
]]></php>
                Désormais ce n'est que si notre <code>$connection</code>
                est appelée par la méthode <code>query()</code>
                que sera retourné le <code>$result</code>,
                lui-même s'arrêtant au troisième appel
                à <code>next()</code>.
                Ce devrait être suffisant comme information
                pour que notre classe <code>UserFinder</code>,
                la classe effectivement testée ici,
                fasse son boulot.
                Un test très précis et toujours pas
                de base de données en vue.
            </p>
            <p>
                Nous pourrsion affiner ce test encore plus
                en insistant pour que la bonne requête
                soit envoyée...
<php><![CDATA[
$connection->returns('selectQuery', $result, array(<strong>'select name, id from people'</strong>));
]]></php>
                Là, c'est une mauvaise idée.
            </p>
            <p>
                Niveau objet, nous avons un <code>UserFinder</code>
                qui parle à une base de données à travers une interface géante -
                l'ensemble du SQL.
                Imaginez si nous avions écrit un grand nombre de tests
                qui dépendrait désormais de cette requête SQL précise.
                Ces requêtes pourraient changer en masse pour tout un tas
                de raisons non liés à ce test spécifique.
                Par exemple, la règle pour les quotes pourrait changer,
                un nom de table pourrait évoluer, une table de liaison pourrait
                être ajouté, etc.
                Cela entrainerait une ré-écriture de tous les tests à chaque fois
                qu'un remaniement est fait, alors même que le comportement lui
                n'a pas bougé.
                Les tests sont censés aider au remaniement, pas le bloquer.
                Pour ma part, je préfère avoir une suite de tests qui passent
                quand je fais évoluer le nom des tables.
            </p>
            <p>
                Et si vous voulez une règle, c'est toujours mieux de ne pas
                créer un objet fantaisie sur une grosse interface.
            </p>
            <p>
            	Par contrast, voici le test complet...
<php><![CDATA[
class DatabaseTest extends UnitTestCase {<strong>
    function setUp() { ... }
    function tearDown() { ... }</strong>

    function testUserFinderReadsResultsFromDatabase() {
        $finder = new UserFinder(<strong>new DatabaseConnection()</strong>);
        $finder->add('tom');
        $finder->add('dick');
        $finder->add('harry');
        $this->assertIdentical(
                $finder->findNames(),
                array('tom', 'dick', 'harry'));
    }
}
]]></php>
                Ce test est immunisé contre le changement de schéma.
                Il échouera uniquement si vous changez la fonctionnalité,
                ce qui correspond bien à ce qu'un test doit faire.
            </p>
            <p>
            	Il faut juste faire attention à ces méthodes <code>setUp()</code>
            	et <code>tearDown()</code> que nous avons survolé pour l'instant.
            	Elles doivent vider les tables de la base de données
            	et s'assurer que le schéma est bien défini.
            	Cela peut se engendrer un peu de travail supplémentaire,
            	mais d'ordinaire ce type de code existe déjà - à commencer pour
            	le déploiement.
            </p>
            <p>
                Il y a au moins un endroit où vous aurez besoin d'objets fantaisie :
                c'est la simulation des erreurs.
                Exemple, la base de données tombe pendant que <code>UserFinder</code>
                fait son travail. Le <code>UserFinder</code> se comporte-t-il bien ?
<php><![CDATA[
class DatabaseTest extends UnitTestCase {

    function testUserFinder() {
        $connection = new MockDatabaseConnection();<strong>
        $connection->throwOn('selectQuery', new TimedOut('Ouch!'));</strong>
        $alert = new MockAlerts();<strong>
        $alert->expectOnce('notify', 'Database is busy - please retry');</strong>
        $finder = new UserFinder($connection, $alert);
        $this->assertIdentical($finder->findNames(), array());
    }
}
]]></php>
                Nous avons transmis au <code>UserFinder</code>
                un objet <code>$alert</code>.
                Il va transmettre un certain nombre de belles notifications
                à l'interface utilisatuer en cas d'erreur.
                Nous préfèrerions éviter de saupoudrer notre code avec
                des commandes <code>print</code> codées en dur si nous pouvons
                l'éviter.
                Emballer les moyens de sortie veut dire que nous pouvons utiliser
                ce code partout. Et cela rend notre code plus facile.
            </p>
            <p>
                Pour faire passer ce test, le finder doit écrire un message sympathique
                et compréhensible à l'<code>$alert</code>, plutôt que de propager
                l'exception. Jusque là, tout va bien.
            </p>
            <p>
                Comment faire en sorte que la <code>DatabaseConnection</code> fantaisie
                soulève une exception ?
                Nous la générons avec la méthode <code>throwOn</code> sur l'objet fantaisie.
            </p>
            <p>
                Enfin, que se passe-t-il si la méthode voulue pour la simulation
                n'existe pas encore ?
                Si vous définissez une valeur de retour sur une méthode absente,
                alors SimpleTest vous répondra avec une erreur.
                Et si vous utilisez <code>__call()</code> pour simuler
                des méthodes dynamiques ?
            </p>
            <p>
                Les objets avec des interfaces dynamiques, avec <code>__call</code>,
                peuvent être problématiques dans l'implémentation courante
                des objets fantaisie.
                Vous pouvez en créer un autour de la méthode <code>__call()</code>
                mais c'est très laid.
                Et pourquoi un test devrait connaître quelque chose avec un niveau
                si bas dans l'implémentation. Il n'a besoin que de simuler l'appel.
            </p>
            <p>
                Il y a bien moyen de contournement : ajouter des méthodes complémentaires
                à l'objet fantaisie à la génération.
<php><![CDATA[
<strong>Mock::generate('DatabaseConnection', 'MockDatabaseConnection', array('setOptions'));</strong>
]]></php>
                Dans une longue suite de tests cela pourrait entraîner des problèmes,
                puisque vous avez probablement déjà une version fantaisie
                de la classe appellée <code>MockDatabaseConnection</code>
                sans les méthodes complémentaires.
                Le générateur de code ne générera pas la version fantaisie de la classe
                s'il en existe déjà une version avec le même nom.
                Il vous deviendra impossible de déterminer où est passée votre méthode
                si une autre définition a été lancé au préalable.
            </p>
            <p>
                Pour pallier à ce problème, SimpleTest vous permet de choisir
                n'importe autre nom pour la nouvelle classe au moment même où
                vous ajouter les méthodes complémentaires.
<php><![CDATA[
Mock::generate('DatabaseConnection', <strong>'MockDatabaseConnectionWithOptions'</strong>, array('setOptions'));
]]></php>
                Ici l'objet fantaisie se comportera comme si
                <code>setOptions()</code> existait bel et bien
                dans la classe originale.
            </p>
            <p>
                Les objets fantaisie ne peuvent être utilisés qu'à l'intérieur
                des scénarios de test, étant donné qu'à l'apparition d'une attente
                ils envoient des messages directement au scénario de test courant.
                Les créer en dehors d'un scénario de test entraînera une erreur
                de run time quand une attente est déclenchée et qu'il n'y a pas
                de scénario de test en cours pour recevoir le message.
                Nous pouvons désormais couvrir ces attentes.
            </p>
        </section>
        <section name="expectations" title="Objets fantaisie en tant que critiques">
            <p>
                Même si les bouchons serveur isolent vos tests des perturbations
				du monde réel, ils n'apportent que le moitié des bénéfices possibles.
				Vous pouvez obtenir une classe de test qui reçoive les bons messages,
				mais cette nouvelle classe envoie-t-elle les bons ?
				Le tester peut devenir très bordélique sans
				une librairie d'objets fantaise.
            </p>
			<p>
                Voici un exemple, prenons une classe <code>PageController</code>
				toute simple qui traitera un formulaire de paiement
				par carte bleue...
<php><![CDATA[
class PaymentForm extends PageController {
    function __construct($alert, $payment_gateway) { ... }
    function makePayment($request) { ... }
}
]]></php>
                Cette classe a besoin d'un <code>PaymentGateway</code>
				pour parler concrètement à la banque.
				Il utilise aussi un objet <code>Alert</code>
				pour gérer les erreurs.
				Cette dernière classe parle à la page ou au template.
				Elle est responsable de l'affichage du message d'erreur
				et de la mise en valeur de tout champ du formulaire
				qui serait incorrecte.
            </p>
            <p>
                Elle pourrait ressembler à...
<php><![CDATA[
class Alert {
    function warn($warning, $id) {
        print '<div class="warning">' . $warning . '</div>';
        print '<style type="text/css">#' . $id . ' { background-color: red }</style>';
    }
}
]]></php>
            </p>
            <p>
                Portons notre attention à la méthode <code>makePayment()</code>.
				Si nous n'inscrivons pas un numéro &quot;CVV2&quot; (celui à trois
				chiffre au dos de la carte bleue), nous souhaitons afficher
				une erreur plutôt que d'essayer de traiter le paiement. 
				En mode test...
<php><![CDATA[
<?php
require_once('simpletest/autorun.php');
require_once('payment_form.php');
Mock::generate('Alert');
Mock::generate('PaymentGateway');

class PaymentFormFailuresShouldBeGraceful extends UnitTestCase {

    function testMissingCvv2CausesAlert() {
        $alert = new MockAlert();
        <strong>$alert->expectOnce(
                    'warn',
                    array('Missing three digit security code', 'cvv2'));</strong>
        $controller = new PaymentForm(<strong>$alert</strong>, new MockPaymentGateway());
        $controller->makePayment($this->requestWithMissingCvv2());
    }

    function requestWithMissingCvv2() { ... }
}
?>
]]></php>
                Première question : où sont passés les assertions ?
            </p>
            <p>
                L'appel à <code>expectOnce('warn', array(...))</code> annonce
				à l'objet fantaisie qu'il faut s'attendre à un appel à <code>warn()</code>
				avant la fin du test.
				Quand il débouche sur l'appel à <code>warn()</code>, il vérifie
				les arguments. Si ceux-ci ne correspondent pas, alors un échec
				est généré. Il échouera aussi si la méthode n'est jamais appelée.
            </p>
            <p>
                Non seulement le test ci-dessus s'assure que <code>warn</code>
				a bien été appelé, mais en plus qu'il a bien reçu la chaîne
				de caractère &quot;Missing three digit security code&quot;
				et même le tag &quot;cvv2&quot;.
				L'équivalent de <code>assertIdentical()</code> est appliqué
				aux deux champs quand les paramètres sont comparés.
            </p>
            <p>
                Si le contenu du message vous importe peu, surtout dans le cas
				d'une interface utilisateur qui change régulièrement,
				nous pouvons passer ce paramètre avec l'opérateur &quot;*&quot;...
<php><![CDATA[
class PaymentFormFailuresShouldBeGraceful extends UnitTestCase {

    function testMissingCvv2CausesAlert() {
        $alert = new MockAlert();
        $alert->expectOnce('warn', array(<strong>'*'</strong>, 'cvv2'));
        $controller = new PaymentForm($alert, new MockPaymentGateway());
        $controller->makePayment($this->requestWithMissingCvv2());
    }

    function requestWithMissingCvv2() { ... }
}
]]></php>
                Nous pouvons même rendre le test encore moins spécifique
				en supprimant complètement la liste des paramètres...
<php><![CDATA[
function testMissingCvv2CausesAlert() {
    $alert = new MockAlert();
    <strong>$alert->expectOnce('warn');</strong>
    $controller = new PaymentForm($alert, new MockPaymentGateway());
    $controller->makePayment($this->requestWithMissingCvv2());
}
]]></php>
                Ceci vérifiera uniquement si la méthode a été appelé,
				ce qui est peut-être un peu drastique dans ce cas.
				Plus tard, nous verrons comment alléger les attentes
				plus précisement.
            </p>
            <p>
                Des tests sans assertions peuvent être à la fois compacts
				et très expressifs. Parce que nous interceptons l'appel
				sur le chemin de l'objet, ici de classe <code>Alert</code>,
				nous évitons de tester l'état par la suite.
				Cela évite les assertions dans les tests, mais aussi
				l'obligation d'ajouter des accesseurs uniquement
				pour les tests dans le code original.
				Si vous en arrivez à ajouter des accesseurs de ce type,
				on parle alors de &quot;state based testing&quot; dans le jargon
				(&quot;test piloté par l'état&quot;),
				il est probablement plus que temps d'utiliser
				des objets fantaisie dans vos tests.
				On peut alors parler de &quot;behaviour based testing&quot;
				(ou &quot;test piloté par le comportement&quot;) :
				c'est largement mieux !
            </p>
            <p>
                Ajoutons un autre test.
				Assurons nous que nous essayons même pas un paiement sans CVV2...
<php><![CDATA[
class PaymentFormFailuresShouldBeGraceful extends UnitTestCase {

    function testMissingCvv2CausesAlert() { ... }

    function testNoPaymentAttemptedWithMissingCvv2() {
        $payment_gateway = new MockPaymentGateway();
        <strong>$payment_gateway->expectNever('pay');</strong>
        $controller = new PaymentForm(new MockAlert(), $payment_gateway);
        $controller->makePayment($this->requestWithMissingCvv2());
    }

    ...
}
]]></php>
                Vérifier une négation peut être très difficile
				dans les tests, mais <code>expectNever()</code>
				rend l'opération très facile heureusement.
            </p>
            <p>
                <code>expectOnce()</code> et <code>expectNever()</code> sont
				suffisants pour la plupart des tests, mais
				occasionnellement vous voulez tester plusieurs évènements.
				D'ordinaire pour des raisons d'usabilité, nous souhaitons
				que tous les champs manquants du formulaire soient
				mis en relief, et pas uniquement le premier.
				Cela veut dire que nous devrions voir de multiples appels
				à <code>Alert::warn()</code>, pas juste un...
<php><![CDATA[
function testAllRequiredFieldsHighlightedOnEmptyRequest() {
    $alert = new MockAlert();<strong>
    $alert->expectAt(0, 'warn', array('*', 'cc_number'));
    $alert->expectAt(1, 'warn', array('*', 'expiry'));
    $alert->expectAt(2, 'warn', array('*', 'cvv2'));
    $alert->expectAt(3, 'warn', array('*', 'card_holder'));
    $alert->expectAt(4, 'warn', array('*', 'address'));
    $alert->expectAt(5, 'warn', array('*', 'postcode'));
    $alert->expectAt(6, 'warn', array('*', 'country'));
    $alert->expectCallCount('warn', 7);</strong>
    $controller = new PaymentForm($alert, new MockPaymentGateway());
    $controller->makePayment($this->requestWithMissingCvv2());
}
]]></php>
                Le compteur dans <code>expectAt()</code> précise
				le nombre de fois que la méthode a déjà été appelée.
				Ici nous vérifions que chaque champ sera bien mis en relief.
            </p>
            <p>
                Notez que nous sommes forcé de tester l'ordre en même temps.
				SimpleTest n'a pas encore de moyen pour éviter cela,
				mais dans une version future ce sera corrigé.
            </p>
            <p>
                Voici la liste complètes des attentes
				que vous pouvez préciser sur une objet fantaisie
				dans <a href="http://simpletest.org/">SimpleTest</a>.
				Comme pour les assertions, ces méthodes prennent en option
				un message d'erreur.
                <table>
                    <thead><tr><th>Attente</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><code>expect($method, $args)</code></td>
                            <td>Les arguements doivent correspondre si appelés</td>
                        </tr>
                        <tr>
                            <td><code>expectAt($timing, $method, $args)</code></td>
                            <td>Les arguements doiven correspondre si appelés lors du passage numéro <code>$timing</code></td>
                        </tr>
                        <tr>
                            <td><code>expectCallCount($method, $count)</code></td>
                            <td>La méthode doit être appelée exactement <code>$count</code> fois</td>
                        </tr>
                        <tr>
                            <td><code>expectMaximumCallCount($method, $count)</code></td>
                            <td>La méthode ne doit pas être appelée plus de <code>$count</code> fois</td>
                        </tr>
                        <tr>
                            <td><code>expectMinimumCallCount($method, $count)</code></td>
                            <td>La méthode ne doit pas être appelée moins de <code>$count</code> fois</td>
                        </tr>
                        <tr>
                            <td><code>expectNever($method)</code></td>
                            <td>La méthode ne doit jamais être appelée</td>
                        </tr>
                        <tr>
                            <td><code>expectOnce($method, $args)</code></td>
                            <td>La méthode ne doit être appelée qu'une seule fois et avec les arguments (en option)</td>
                        </tr>
                        <tr>
                            <td><code>expectAtLeastOnce($method, $args)</code></td>
                            <td>La méthode doit être appelée au moins une seule fois et toujours avec au moins un des arguments attendus</td>
                        </tr>
                    </tbody>
                </table>
                Où les paramètres sont...
                <dl>
                    <dt class="new_code">$method</dt>
                    <dd>
                    	Le nom de la méthode, sous la forme d'une chaîne de caractères,
						à laquelle il faut appliquer la condition.
					</dd>
                    <dt class="new_code">$args</dt>
                    <dd>
                        Les argumetns sous la forme d'une liste.
						Les jokers peuvent être inclus de la même manière
						que pour <code>setReturn()</code>.
						Cet argument est optionnel pour <code>expectOnce()</code>
                        et <code>expectAtLeastOnce()</code>.
                    </dd>
                    <dt class="new_code">$timing</dt>
                    <dd>
                        La seule marque dans le temps pour tester la condition.
						Le premier appel commence à zéro et le comptage se fait
						séparement sur chaque méthode.
                    </dd>
                    <dt class="new_code">$count</dt>
                    <dd>Le nombre d'appels attendu.</dd>
                </dl>
            </p>
            <p>
                Si vous n'avez qu'un seul appel dans votre test, assurez vous
				d'utiliser <code>expectOnce</code>.<br />
                Utiliser <code>$mocked->expectAt(0, 'method', 'args);</code>
				tout seul ne permettra qu'à la méthode de ne jamais être appelée.
				Vérifier les arguements et le comptage total sont pour le moment
				indépendants.
				Ajouter une attente <code>expectCallCount()</code> quand
				vous utilisez <code>expectAt()</code> (dans le cas sans appel)
				est permis.
            </p>
            <p>
                Comme les assertions à l'intérieur des scénarios de test,
				toutes ces attentes peuvent incorporer une surchage
				sur le message sous la forme d'un paramètre supplémentaire.
				Par ailleurs le message original peut être inclus dans la sortie
				avec &quot;%s&quot;.
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#what">Que sont les objets fantaisie ?</a>
        </link>
        <link>
            <a href="#creation">Créer des objets fantaisie</a>.
        </link>
        <link>
            <a href="#expectations">Les objets fantaisie en tant que critiques</a> avec les attentes.
        </link>
    </internal>
    <external>
        <link>
            Le papier original sur les Objets fantaisie ou
            <a href="http://www.mockobjects.com/">Mock objects</a>.
        </link>
        <link>
            La page du projet SimpleTest sur <a href="http://sourceforge.net/projects/simpletest/">SourceForge</a>.
        </link>
        <link>
            La page d'accueil de SimpleTest sur <a href="http://www.lastcraft.com/simple_test.php">LastCraft</a>.
        </link>
    </external>
    <meta>
        <keywords>
            software development,
            php programming,
            programming php,
            software development tools,
            php tutorial,
            free php scripts,
            architecture,
            ressources php,
            mock objects,
			objets fantaisie,
            junit,
            php testing,
            unit test,
            php testing,
            jmock,
            nmock
        </keywords>
    </meta>
</page>
